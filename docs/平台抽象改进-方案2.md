基于现有代码，我来提供一个平台抽象改进方案，减少条件编译的重复，提供更好的跨平台抽象设计。

## 1. 创建平台抽象层

```rust
// src/platform/mod.rs
use crate::types::{WindowInfo, WindowRect};

#[cfg(windows)]
mod windows;
#[cfg(not(windows))]
mod unix;

#[cfg(windows)]
use windows as platform_impl;
#[cfg(not(windows))]
use unix as platform_impl;

// 统一的平台抽象 trait
pub trait PlatformInterface {
    fn get_all_windows_with_size() -> Vec<WindowInfo>;
    fn find_windows(
        pid_filter: &Option<String>,
        name_filter: &Option<String>,
        title_filter: &Option<String>,
        process_names: &[(u32, String)],
    ) -> Vec<WindowHandle>;
}

// 窗口操作句柄
pub struct WindowHandle {
    pub platform_handle: platform_impl::PlatformWindowHandle,
    pub pid: u32,
    pub title: String,
}

impl WindowHandle {
    pub fn minimize(&self) -> Result<(), String> {
        self.platform_handle.minimize()
    }

    pub fn maximize(&self) -> Result<(), String> {
        self.platform_handle.maximize()
    }

    pub fn restore(&self) -> Result<(), String> {
        self.platform_handle.restore()
    }
}

// 公共接口函数 - 委托给平台实现
pub fn get_all_windows_with_size() -> Vec<WindowInfo> {
    platform_impl::get_all_windows_with_size()
}

pub fn find_windows(
    pid_filter: &Option<String>,
    name_filter: &Option<String>,
    title_filter: &Option<String>,
    process_names: &[(u32, String)],
) -> Vec<WindowHandle> {
    platform_impl::find_windows(pid_filter, name_filter, title_filter, process_names)
}
```

## 2. Windows 平台实现

```rust
// src/platform/windows.rs
use crate::types::{WindowInfo, WindowRect};
use super::WindowHandle;
use std::ffi::OsString;
use std::os::windows::ffi::OsStringExt;
use windows::Win32::Foundation::{HWND, BOOL, LPARAM, RECT};
use windows::Win32::UI::WindowsAndMessaging::{
    EnumWindows, GetWindowThreadProcessId, IsWindowVisible, GetWindowTextW, 
    GetWindowRect, ShowWindow, SW_MINIMIZE, SW_MAXIMIZE, SW_RESTORE
};

pub struct PlatformWindowHandle {
    pub hwnd: HWND,
}

impl PlatformWindowHandle {
    pub fn minimize(&self) -> Result<(), String> {
        unsafe {
            ShowWindow(self.hwnd, SW_MINIMIZE);
        }
        Ok(())
    }

    pub fn maximize(&self) -> Result<(), String> {
        unsafe {
            ShowWindow(self.hwnd, SW_MAXIMIZE);
        }
        Ok(())
    }

    pub fn restore(&self) -> Result<(), String> {
        unsafe {
            ShowWindow(self.hwnd, SW_RESTORE);
        }
        Ok(())
    }
}

pub fn get_all_windows_with_size() -> Vec<WindowInfo> {
    let mut windows = Vec::new();
    
    unsafe extern "system" fn enum_windows_proc(hwnd: HWND, lparam: LPARAM) -> BOOL {
        let windows_ptr = lparam.0 as *mut Vec<WindowInfo>;
        
        if IsWindowVisible(hwnd).into() {
            if let Some(window_info) = get_window_info(hwnd) {
                unsafe {
                    (*windows_ptr).push(window_info);
                }
            }
        }
        
        true.into()
    }
    
    unsafe {
        let _ = EnumWindows(
            Some(enum_windows_proc),
            LPARAM(&mut windows as *mut _ as isize),
        );
    }
    
    windows
}

pub fn find_windows(
    pid_filter: &Option<String>,
    name_filter: &Option<String>,
    title_filter: &Option<String>,
    process_names: &[(u32, String)],
) -> Vec<WindowHandle> {
    let mut windows = Vec::new();
    
    unsafe extern "system" fn enum_windows_proc(hwnd: HWND, lparam: LPARAM) -> BOOL {
        let windows_ptr = lparam.0 as *mut Vec<WindowHandle>;
        
        if IsWindowVisible(hwnd).into() {
            if let Some((pid, title)) = get_window_pid_and_title(hwnd) {
                unsafe {
                    (*windows_ptr).push(WindowHandle {
                        platform_handle: PlatformWindowHandle { hwnd },
                        pid,
                        title,
                    });
                }
            }
        }
        
        true.into()
    }
    
    unsafe {
        let _ = EnumWindows(
            Some(enum_windows_proc),
            LPARAM(&mut windows as *mut _ as isize),
        );
    }

    apply_window_filters(windows, pid_filter, name_filter, title_filter, process_names)
}

// 辅助函数
unsafe fn get_window_info(hwnd: HWND) -> Option<WindowInfo> {
    let (pid, title) = get_window_pid_and_title(hwnd)?;
    
    let mut rect = RECT::default();
    if GetWindowRect(hwnd, &mut rect).is_err() {
        return None;
    }
    
    let window_rect = WindowRect::new(
        rect.left,
        rect.top,
        rect.right - rect.left,
        rect.bottom - rect.top
    );
    
    Some(WindowInfo {
        pid,
        title,
        rect: window_rect,
    })
}

unsafe fn get_window_pid_and_title(hwnd: HWND) -> Option<(u32, String)> {
    // Get window title
    let mut title_vec = vec![0u16; 512];
    let title_len = GetWindowTextW(hwnd, &mut title_vec);
    
    if title_len <= 0 {
        return None;
    }
    
    title_vec.truncate(title_len as usize);
    let title_os = OsString::from_wide(&title_vec);
    let title = title_os.to_string_lossy().to_string();
    
    if title.trim().is_empty() {
        return None;
    }
    
    // Get process ID
    let mut pid: u32 = 0;
    GetWindowThreadProcessId(hwnd, Some(&mut pid));
    
    if pid == 0 {
        return None;
    }
    
    Some((pid, title))
}

fn apply_window_filters(
    windows: Vec<WindowHandle>,
    pid_filter: &Option<String>,
    name_filter: &Option<String>,
    title_filter: &Option<String>,
    process_names: &[(u32, String)],
) -> Vec<WindowHandle> {
    windows.into_iter()
        .filter(|window| {
            // PID filter
            if let Some(pid) = pid_filter {
                if window.pid.to_string() != *pid {
                    return false;
                }
            }

            // Name filter
            if let Some(name) = name_filter {
                let process_name = process_names
                    .iter()
                    .find(|(process_pid, _)| *process_pid == window.pid)
                    .map(|(_, name)| name.to_lowercase())
                    .unwrap_or_default();
                
                if !process_name.contains(&name.to_lowercase()) {
                    return false;
                }
            }

            // Title filter
            if let Some(title) = title_filter {
                if !window.title.to_lowercase().contains(&title.to_lowercase()) {
                    return false;
                }
            }

            true
        })
        .collect()
}
```

## 3. Unix 平台实现

```rust
// src/platform/unix.rs
use crate::types::{WindowInfo, WindowRect};
use super::WindowHandle;

// Unix 平台的简化实现
pub struct PlatformWindowHandle;

impl PlatformWindowHandle {
    pub fn minimize(&self) -> Result<(), String> {
        Err("Window operations not supported on this platform".to_string())
    }

    pub fn maximize(&self) -> Result<(), String> {
        Err("Window operations not supported on this platform".to_string())
    }

    pub fn restore(&self) -> Result<(), String> {
        Err("Window operations not supported on this platform".to_string())
    }
}

pub fn get_all_windows_with_size() -> Vec<WindowInfo> {
    // 在 Unix 系统上返回空向量或使用其他方法
    // 这里可以根据需要集成 x11 或 wayland 支持
    eprintln!("Warning: Window size detection is limited on non-Windows systems");
    Vec::new()
}

pub fn find_windows(
    _pid_filter: &Option<String>,
    _name_filter: &Option<String>,
    _title_filter: &Option<String>,
    _process_names: &[(u32, String)],
) -> Vec<WindowHandle> {
    // 在 Unix 系统上返回空向量
    eprintln!("Warning: Window operations are not supported on this platform");
    Vec::new()
}
```

## 4. 修改 window.rs

```rust
// src/window.rs
use crate::types::{WindowInfo, WindowRect};

mod platform;
pub use platform::{WindowHandle, find_windows, get_all_windows_with_size};

// 保持向后兼容的函数
pub fn get_all_windows() -> Vec<(u32, String)> {
    get_all_windows_with_size()
        .into_iter()
        .map(|window| (window.pid, window.title))
        .collect()
}

// 删除原来的 manipulation 模块，功能已移动到 platform 模块
```

## 5. 修改 main.rs

```rust
// 在 src/main.rs 中更新导入
mod types;
mod cli;
mod process;
mod window;
mod output;
mod platform; // 新增

// 更新使用 window 模块的地方
use window::{get_all_windows_with_size, find_windows, WindowHandle};

// 删除原来的 WindowOperation 枚举和相关的平台特定代码
// 这些现在由平台抽象层处理
```

## 6. 更新 Cargo.toml

```toml
[dependencies]
sysinfo = "0.30.5"
clap = { version = "4.4", features = ["derive"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.9"
csv = "1.3"

# 平台特定依赖
[target.'cfg(windows)'.dependencies]
windows = { version = "0.52", features = [
    "Win32_Foundation",
    "Win32_UI_WindowsAndMessaging",
    "Win32_System_Threading",
] }

# 可选：Unix 平台支持
[target.'cfg(unix)'.dependencies]
# 可以在这里添加 x11 或 wayland 的依赖
```

## 设计优势

1. **清晰的抽象边界**: 平台特定代码完全隔离在 `platform` 模块中
2. **统一的接口**: 所有平台都实现相同的 trait，提供一致的 API
3. **减少条件编译**: 主代码中不再需要大量的 `#[cfg(windows)]` 条件编译
4. **易于扩展**: 添加新平台只需要实现 `PlatformInterface` trait
5. **更好的测试**: 可以更容易地为平台抽象编写测试
6. **类型安全**: 使用 trait 和泛型确保类型安全

这个设计使得跨平台支持更加模块化和可维护，同时为将来添加更多平台支持（如 macOS、Linux 的 X11/Wayland）提供了清晰的路径。