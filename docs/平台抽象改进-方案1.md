基于您的代码，我来重构平台抽象，减少条件编译的重复：

```rust
// src/window/platform.rs
use crate::types::{WindowInfo, WindowRect};

// 平台无关的窗口操作 trait
pub trait WindowOperations {
    fn get_all_windows_with_size() -> Vec<WindowInfo>;
    fn find_windows(
        pid_filter: &Option<String>,
        name_filter: &Option<String>,
        title_filter: &Option<String>,
        process_names: &[(u32, String)],
    ) -> Vec<WindowHandle>;
}

// 平台无关的窗口句柄
pub struct WindowHandle {
    pub pid: u32,
    pub title: String,
    #[cfg(windows)]
    pub hwnd: windows::Win32::Foundation::HWND,
    #[cfg(unix)]
    pub window_id: u64, // X11 Window ID or other Unix window identifier
}

impl WindowHandle {
    pub fn minimize(&self) -> Result<(), String> {
        platform::minimize_window(self)
    }

    pub fn maximize(&self) -> Result<(), String> {
        platform::maximize_window(self)
    }

    pub fn restore(&self) -> Result<(), String> {
        platform::restore_window(self)
    }
}

// 平台特定的实现模块
#[cfg(windows)]
pub mod windows_impl {
    use super::*;
    use std::ffi::OsString;
    use std::os::windows::ffi::OsStringExt;
    use windows::Win32::Foundation::{HWND, BOOL, LPARAM, RECT};
    use windows::Win32::UI::WindowsAndMessaging::{
        EnumWindows, GetWindowThreadProcessId, IsWindowVisible, GetWindowTextW, GetWindowRect,
        ShowWindow, SW_MINIMIZE, SW_MAXIMIZE, SW_RESTORE
    };

    impl WindowOperations for super::WindowOperationsImpl {
        fn get_all_windows_with_size() -> Vec<WindowInfo> {
            let mut windows = Vec::new();
            
            unsafe extern "system" fn enum_windows_proc(hwnd: HWND, lparam: LPARAM) -> BOOL {
                let windows_ptr = lparam.0 as *mut Vec<WindowInfo>;
                
                if IsWindowVisible(hwnd).into() {
                    // Get window title
                    let mut title_vec = vec![0u16; 512];
                    let title_len = GetWindowTextW(hwnd, &mut title_vec);
                    
                    if title_len > 0 {
                        title_vec.truncate(title_len as usize);
                        let title_os = OsString::from_wide(&title_vec);
                        let title = title_os.to_string_lossy().to_string();
                        
                        // Only include non-empty titles
                        if !title.trim().is_empty() {
                            // Get window rectangle
                            let mut rect = RECT::default();
                            if GetWindowRect(hwnd, &mut rect).is_ok() {
                                let window_rect = WindowRect::new(
                                    rect.left,
                                    rect.top,
                                    rect.right - rect.left,
                                    rect.bottom - rect.top
                                );
                                
                                let mut pid: u32 = 0;
                                GetWindowThreadProcessId(hwnd, Some(&mut pid));
                                
                                if pid != 0 {
                                    unsafe {
                                        (*windows_ptr).push(WindowInfo {
                                            pid,
                                            title,
                                            rect: window_rect,
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                
                true.into() // Continue enumeration
            }
            
            unsafe {
                let _ = EnumWindows(
                    Some(enum_windows_proc),
                    LPARAM(&mut windows as *mut _ as isize),
                );
            }
            
            windows
        }

        fn find_windows(
            pid_filter: &Option<String>,
            name_filter: &Option<String>,
            title_filter: &Option<String>,
            process_names: &[(u32, String)],
        ) -> Vec<WindowHandle> {
            let mut windows = Vec::new();
            
            unsafe extern "system" fn enum_windows_proc(hwnd: HWND, lparam: LPARAM) -> BOOL {
                let windows_ptr = lparam.0 as *mut Vec<WindowHandle>;
                
                if IsWindowVisible(hwnd).into() {
                    // Get window title
                    let mut title_vec = vec![0u16; 512];
                    let title_len = GetWindowTextW(hwnd, &mut title_vec);
                    
                    if title_len > 0 {
                        title_vec.truncate(title_len as usize);
                        let title_os = OsString::from_wide(&title_vec);
                        let title = title_os.to_string_lossy().to_string();
                        
                        if !title.trim().is_empty() {
                            let mut pid: u32 = 0;
                            GetWindowThreadProcessId(hwnd, Some(&mut pid));
                            
                            if pid != 0 {
                                unsafe {
                                    (*windows_ptr).push(WindowHandle {
                                        hwnd,
                                        pid,
                                        title,
                                    });
                                }
                            }
                        }
                    }
                }
                
                true.into()
            }
            
            unsafe {
                let _ = EnumWindows(
                    Some(enum_windows_proc),
                    LPARAM(&mut windows as *mut _ as isize),
                );
            }

            // Apply filters
            windows.into_iter()
                .filter(|window: &WindowHandle| {
                    // PID filter
                    if let Some(pid) = pid_filter {
                        if window.pid.to_string() != *pid {
                            return false;
                        }
                    }

                    // Name filter
                    if let Some(name) = name_filter {
                        let process_name = process_names
                            .iter()
                            .find(|(process_pid, _)| *process_pid == window.pid)
                            .map(|(_, name)| name.to_lowercase())
                            .unwrap_or_default();
                        
                        if !process_name.contains(&name.to_lowercase()) {
                            return false;
                        }
                    }

                    // Title filter
                    if let Some(title) = title_filter {
                        if !window.title.to_lowercase().contains(&title.to_lowercase()) {
                            return false;
                        }
                    }

                    true
                })
                .collect()
        }
    }

    pub fn minimize_window(window: &WindowHandle) -> Result<(), String> {
        unsafe {
            ShowWindow(window.hwnd, SW_MINIMIZE);
        }
        Ok(())
    }

    pub fn maximize_window(window: &WindowHandle) -> Result<(), String> {
        unsafe {
            ShowWindow(window.hwnd, SW_MAXIMIZE);
        }
        Ok(())
    }

    pub fn restore_window(window: &WindowHandle) -> Result<(), String> {
        unsafe {
            ShowWindow(window.hwnd, SW_RESTORE);
        }
        Ok(())
    }
}

#[cfg(unix)]
pub mod unix_impl {
    use super::*;

    impl WindowOperations for super::WindowOperationsImpl {
        fn get_all_windows_with_size() -> Vec<WindowInfo> {
            // Unix/Linux implementation using x11rb or other window system
            // This is a simplified placeholder implementation
            println!("Warning: Window size detection is limited on Unix systems");
            Vec::new()
        }

        fn find_windows(
            _pid_filter: &Option<String>,
            _name_filter: &Option<String>,
            _title_filter: &Option<String>,
            _process_names: &[(u32, String)],
        ) -> Vec<WindowHandle> {
            // Unix/Linux implementation placeholder
            println!("Warning: Window manipulation is limited on Unix systems");
            Vec::new()
        }
    }

    pub fn minimize_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window minimization not implemented for Unix systems".to_string())
    }

    pub fn maximize_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window maximization not implemented for Unix systems".to_string())
    }

    pub fn restore_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window restoration not implemented for Unix systems".to_string())
    }
}

#[cfg(not(any(windows, unix)))]
pub mod other_impl {
    use super::*;

    impl WindowOperations for super::WindowOperationsImpl {
        fn get_all_windows_with_size() -> Vec<WindowInfo> {
            println!("Warning: Window detection not supported on this platform");
            Vec::new()
        }

        fn find_windows(
            _pid_filter: &Option<String>,
            _name_filter: &Option<String>,
            _title_filter: &Option<String>,
            _process_names: &[(u32, String)],
        ) -> Vec<WindowHandle> {
            println!("Warning: Window manipulation not supported on this platform");
            Vec::new()
        }
    }

    pub fn minimize_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window manipulation not supported on this platform".to_string())
    }

    pub fn maximize_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window manipulation not supported on this platform".to_string())
    }

    pub fn restore_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window manipulation not supported on this platform".to_string())
    }
}

// 平台抽象层 - 统一接口
pub struct WindowOperationsImpl;

impl WindowOperations for WindowOperationsImpl {
    fn get_all_windows_with_size() -> Vec<WindowInfo> {
        #[cfg(windows)]
        return windows_impl::get_all_windows_with_size();
        #[cfg(unix)]
        return unix_impl::get_all_windows_with_size();
        #[cfg(not(any(windows, unix)))]
        return other_impl::get_all_windows_with_size();
    }

    fn find_windows(
        pid_filter: &Option<String>,
        name_filter: &Option<String>,
        title_filter: &Option<String>,
        process_names: &[(u32, String)],
    ) -> Vec<WindowHandle> {
        #[cfg(windows)]
        return windows_impl::find_windows(pid_filter, name_filter, title_filter, process_names);
        #[cfg(unix)]
        return unix_impl::find_windows(pid_filter, name_filter, title_filter, process_names);
        #[cfg(not(any(windows, unix)))]
        return other_impl::find_windows(pid_filter, name_filter, title_filter, process_names);
    }
}

// 平台特定的窗口操作函数
mod platform {
    use super::WindowHandle;

    #[cfg(windows)]
    pub use super::windows_impl::{minimize_window, maximize_window, restore_window};
    
    #[cfg(unix)]
    pub use super::unix_impl::{minimize_window, maximize_window, restore_window};
    
    #[cfg(not(any(windows, unix)))]
    pub use super::other_impl::{minimize_window, maximize_window, restore_window};
}
```

```rust
// src/window/mod.rs
mod platform;
use crate::types::{WindowInfo, WindowRect};

// 重新导出公共接口
pub use platform::{WindowOperations, WindowOperationsImpl, WindowHandle};

// 保持向后兼容的公共函数
pub fn get_all_windows_with_size() -> Vec<WindowInfo> {
    WindowOperationsImpl::get_all_windows_with_size()
}

pub fn get_all_windows() -> Vec<(u32, String)> {
    get_all_windows_with_size()
        .into_iter()
        .map(|window| (window.pid, window.title))
        .collect()
}

// 窗口操作模块 - 简化后的统一接口
pub mod manipulation {
    use super::*;

    pub fn find_windows(
        pid_filter: &Option<String>,
        name_filter: &Option<String>,
        title_filter: &Option<String>,
        process_names: &[(u32, String)],
    ) -> Vec<WindowHandle> {
        WindowOperationsImpl::find_windows(pid_filter, name_filter, title_filter, process_names)
    }

    // 统一的窗口操作执行器（使用平台抽象）
    pub fn execute_window_operation(
        operation: crate::main::WindowOperation,
        pid_filter: &Option<String>,
        name_filter: &Option<String>,
        title_filter: &Option<String>,
        process_names: &[(u32, String)],
        all: bool,
    ) -> Result<usize, String> {
        let windows = find_windows(pid_filter, name_filter, title_filter, process_names);
        
        if windows.is_empty() {
            return Err("No matching windows found".to_string());
        }

        if !all && windows.len() > 1 {
            return Err(format!(
                "Multiple windows found ({}). Use --all to {} all matching windows", 
                windows.len(), operation.as_str()
            ));
        }

        let mut count = 0;
        for window in windows {
            let result = match operation {
                crate::main::WindowOperation::Minimize => window.minimize(),
                crate::main::WindowOperation::Maximize => window.maximize(),
                crate::main::WindowOperation::Restore => window.restore(),
            };

            match result {
                Ok(()) => {
                    println!("{}: {} (PID: {})", operation.capitalized(), window.title, window.pid);
                    count += 1;
                }
                Err(e) => {
                    eprintln!("Failed to {} window {} (PID: {}): {}", 
                             operation.as_str(), window.title, window.pid, e);
                }
            }
        }

        Ok(count)
    }
}
```

```rust
// 更新 src/main.rs 中的窗口操作处理
fn handle_window_operation_command(
    pid_filter: Option<String>,
    name_filter: Option<String>,
    title_filter: Option<String>,
    all: bool,
    operation: WindowOperation,
) -> Result<(), Box<dyn std::error::Error>> {
    // Get process names for filtering
    let processes = get_processes();
    let process_names: Vec<(u32, String)> = processes
        .iter()
        .map(|p| (p.pid.parse().unwrap_or(0), p.name.clone()))
        .collect();

    // 使用统一的窗口操作执行器
    match window::manipulation::execute_window_operation(
        operation,
        &pid_filter,
        &name_filter,
        &title_filter,
        &process_names,
        all
    ) {
        Ok(count) => {
            println!("Successfully {} {} window(s)", operation.past_tense(), count);
            Ok(())
        }
        Err(e) => Err(e.into()),
    }
}
```

```toml
# 更新 Cargo.toml 依赖
[package]
name = "pscan"
version = "0.1.0"
edition = "2021"

authors = ["YeMiancheng <ymc.github@gmail.com>"]
description = "A cross-platform process filtering and analysis tool with window detection support"
license = "MIT OR Apache-2.0"
repository = "https://github.com/ymc-github/pscan"
readme = "README.md"
keywords = ["process", "filter", "windows", "system", "monitor", "cli", "utility"]
categories = ["command-line-utilities", "system", "development-tools"]

[[bin]]
name = "pscan"
path = "src/main.rs"

[dependencies]
sysinfo = "0.30.5"
clap = { version = "4.4", features = ["derive"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.9"
csv = "1.3"

# 平台特定依赖
[target.'cfg(windows)'.dependencies]
windows = { version = "0.52", features = [
    "Win32_Foundation",
    "Win32_UI_WindowsAndMessaging", 
    "Win32_System_Threading",
] }

[target.'cfg(unix)'.dependencies]
# 未来可以添加 x11rb 或其他 Unix 窗口系统依赖
# x11rb = "0.12"
```

## 🎯 主要重构点

### 1. **统一的平台抽象接口**
```rust
pub trait WindowOperations {
    fn get_all_windows_with_size() -> Vec<WindowInfo>;
    fn find_windows(...) -> Vec<WindowHandle>;
}
```
所有平台实现相同的trait，确保接口一致性。

### 2. **平台无关的窗口句柄**
```rust
pub struct WindowHandle {
    pub pid: u32,
    pub title: String,
    #[cfg(windows)] pub hwnd: HWND,
    #[cfg(unix)] pub window_id: u64,
}
```
统一的数据结构，平台特定字段使用条件编译。

### 3. **消除重复的条件编译**
- 原来的manipulation模块中重复的Windows/非Windows实现
- 现在每个平台有独立的实现模块
- 统一的接口层处理平台分发

### 4. **更好的错误处理**
```rust
impl WindowHandle {
    pub fn minimize(&self) -> Result<(), String> {
        platform::minimize_window(self)
    }
}
```
统一的错误类型和错误消息。

### 5. **易于扩展**
- 添加新平台只需实现`WindowOperations` trait
- 现有代码无需修改
- 清晰的平台边界

## 📊 重构优势

### 消除的重复：
- **条件编译逻辑** - 原来在多个函数中重复的`#[cfg(windows)]`
- **错误处理代码** - 统一的错误处理模式
- **窗口查找逻辑** - 统一的过滤和验证逻辑

### 提高的可维护性：
- **单一职责** - 每个平台模块只负责自己的实现
- **开闭原则** - 添加新平台不修改现有代码
- **更好的测试** - 可以独立测试每个平台实现

### 更好的跨平台支持：
- **清晰的平台抽象** - 平台特定代码隔离在独立模块
- **统一的接口** - 所有平台提供相同的功能接口
- **渐进式实现** - 可以逐步完善各平台功能

这个重构显著改善了代码的跨平台架构，使添加新平台支持和维护现有平台变得更加容易。