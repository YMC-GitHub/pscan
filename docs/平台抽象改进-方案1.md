åŸºäºæ‚¨çš„ä»£ç ï¼Œæˆ‘æ¥é‡æ„å¹³å°æŠ½è±¡ï¼Œå‡å°‘æ¡ä»¶ç¼–è¯‘çš„é‡å¤ï¼š

```rust
// src/window/platform.rs
use crate::types::{WindowInfo, WindowRect};

// å¹³å°æ— å…³çš„çª—å£æ“ä½œ trait
pub trait WindowOperations {
    fn get_all_windows_with_size() -> Vec<WindowInfo>;
    fn find_windows(
        pid_filter: &Option<String>,
        name_filter: &Option<String>,
        title_filter: &Option<String>,
        process_names: &[(u32, String)],
    ) -> Vec<WindowHandle>;
}

// å¹³å°æ— å…³çš„çª—å£å¥æŸ„
pub struct WindowHandle {
    pub pid: u32,
    pub title: String,
    #[cfg(windows)]
    pub hwnd: windows::Win32::Foundation::HWND,
    #[cfg(unix)]
    pub window_id: u64, // X11 Window ID or other Unix window identifier
}

impl WindowHandle {
    pub fn minimize(&self) -> Result<(), String> {
        platform::minimize_window(self)
    }

    pub fn maximize(&self) -> Result<(), String> {
        platform::maximize_window(self)
    }

    pub fn restore(&self) -> Result<(), String> {
        platform::restore_window(self)
    }
}

// å¹³å°ç‰¹å®šçš„å®ç°æ¨¡å—
#[cfg(windows)]
pub mod windows_impl {
    use super::*;
    use std::ffi::OsString;
    use std::os::windows::ffi::OsStringExt;
    use windows::Win32::Foundation::{HWND, BOOL, LPARAM, RECT};
    use windows::Win32::UI::WindowsAndMessaging::{
        EnumWindows, GetWindowThreadProcessId, IsWindowVisible, GetWindowTextW, GetWindowRect,
        ShowWindow, SW_MINIMIZE, SW_MAXIMIZE, SW_RESTORE
    };

    impl WindowOperations for super::WindowOperationsImpl {
        fn get_all_windows_with_size() -> Vec<WindowInfo> {
            let mut windows = Vec::new();
            
            unsafe extern "system" fn enum_windows_proc(hwnd: HWND, lparam: LPARAM) -> BOOL {
                let windows_ptr = lparam.0 as *mut Vec<WindowInfo>;
                
                if IsWindowVisible(hwnd).into() {
                    // Get window title
                    let mut title_vec = vec![0u16; 512];
                    let title_len = GetWindowTextW(hwnd, &mut title_vec);
                    
                    if title_len > 0 {
                        title_vec.truncate(title_len as usize);
                        let title_os = OsString::from_wide(&title_vec);
                        let title = title_os.to_string_lossy().to_string();
                        
                        // Only include non-empty titles
                        if !title.trim().is_empty() {
                            // Get window rectangle
                            let mut rect = RECT::default();
                            if GetWindowRect(hwnd, &mut rect).is_ok() {
                                let window_rect = WindowRect::new(
                                    rect.left,
                                    rect.top,
                                    rect.right - rect.left,
                                    rect.bottom - rect.top
                                );
                                
                                let mut pid: u32 = 0;
                                GetWindowThreadProcessId(hwnd, Some(&mut pid));
                                
                                if pid != 0 {
                                    unsafe {
                                        (*windows_ptr).push(WindowInfo {
                                            pid,
                                            title,
                                            rect: window_rect,
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                
                true.into() // Continue enumeration
            }
            
            unsafe {
                let _ = EnumWindows(
                    Some(enum_windows_proc),
                    LPARAM(&mut windows as *mut _ as isize),
                );
            }
            
            windows
        }

        fn find_windows(
            pid_filter: &Option<String>,
            name_filter: &Option<String>,
            title_filter: &Option<String>,
            process_names: &[(u32, String)],
        ) -> Vec<WindowHandle> {
            let mut windows = Vec::new();
            
            unsafe extern "system" fn enum_windows_proc(hwnd: HWND, lparam: LPARAM) -> BOOL {
                let windows_ptr = lparam.0 as *mut Vec<WindowHandle>;
                
                if IsWindowVisible(hwnd).into() {
                    // Get window title
                    let mut title_vec = vec![0u16; 512];
                    let title_len = GetWindowTextW(hwnd, &mut title_vec);
                    
                    if title_len > 0 {
                        title_vec.truncate(title_len as usize);
                        let title_os = OsString::from_wide(&title_vec);
                        let title = title_os.to_string_lossy().to_string();
                        
                        if !title.trim().is_empty() {
                            let mut pid: u32 = 0;
                            GetWindowThreadProcessId(hwnd, Some(&mut pid));
                            
                            if pid != 0 {
                                unsafe {
                                    (*windows_ptr).push(WindowHandle {
                                        hwnd,
                                        pid,
                                        title,
                                    });
                                }
                            }
                        }
                    }
                }
                
                true.into()
            }
            
            unsafe {
                let _ = EnumWindows(
                    Some(enum_windows_proc),
                    LPARAM(&mut windows as *mut _ as isize),
                );
            }

            // Apply filters
            windows.into_iter()
                .filter(|window: &WindowHandle| {
                    // PID filter
                    if let Some(pid) = pid_filter {
                        if window.pid.to_string() != *pid {
                            return false;
                        }
                    }

                    // Name filter
                    if let Some(name) = name_filter {
                        let process_name = process_names
                            .iter()
                            .find(|(process_pid, _)| *process_pid == window.pid)
                            .map(|(_, name)| name.to_lowercase())
                            .unwrap_or_default();
                        
                        if !process_name.contains(&name.to_lowercase()) {
                            return false;
                        }
                    }

                    // Title filter
                    if let Some(title) = title_filter {
                        if !window.title.to_lowercase().contains(&title.to_lowercase()) {
                            return false;
                        }
                    }

                    true
                })
                .collect()
        }
    }

    pub fn minimize_window(window: &WindowHandle) -> Result<(), String> {
        unsafe {
            ShowWindow(window.hwnd, SW_MINIMIZE);
        }
        Ok(())
    }

    pub fn maximize_window(window: &WindowHandle) -> Result<(), String> {
        unsafe {
            ShowWindow(window.hwnd, SW_MAXIMIZE);
        }
        Ok(())
    }

    pub fn restore_window(window: &WindowHandle) -> Result<(), String> {
        unsafe {
            ShowWindow(window.hwnd, SW_RESTORE);
        }
        Ok(())
    }
}

#[cfg(unix)]
pub mod unix_impl {
    use super::*;

    impl WindowOperations for super::WindowOperationsImpl {
        fn get_all_windows_with_size() -> Vec<WindowInfo> {
            // Unix/Linux implementation using x11rb or other window system
            // This is a simplified placeholder implementation
            println!("Warning: Window size detection is limited on Unix systems");
            Vec::new()
        }

        fn find_windows(
            _pid_filter: &Option<String>,
            _name_filter: &Option<String>,
            _title_filter: &Option<String>,
            _process_names: &[(u32, String)],
        ) -> Vec<WindowHandle> {
            // Unix/Linux implementation placeholder
            println!("Warning: Window manipulation is limited on Unix systems");
            Vec::new()
        }
    }

    pub fn minimize_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window minimization not implemented for Unix systems".to_string())
    }

    pub fn maximize_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window maximization not implemented for Unix systems".to_string())
    }

    pub fn restore_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window restoration not implemented for Unix systems".to_string())
    }
}

#[cfg(not(any(windows, unix)))]
pub mod other_impl {
    use super::*;

    impl WindowOperations for super::WindowOperationsImpl {
        fn get_all_windows_with_size() -> Vec<WindowInfo> {
            println!("Warning: Window detection not supported on this platform");
            Vec::new()
        }

        fn find_windows(
            _pid_filter: &Option<String>,
            _name_filter: &Option<String>,
            _title_filter: &Option<String>,
            _process_names: &[(u32, String)],
        ) -> Vec<WindowHandle> {
            println!("Warning: Window manipulation not supported on this platform");
            Vec::new()
        }
    }

    pub fn minimize_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window manipulation not supported on this platform".to_string())
    }

    pub fn maximize_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window manipulation not supported on this platform".to_string())
    }

    pub fn restore_window(_window: &WindowHandle) -> Result<(), String> {
        Err("Window manipulation not supported on this platform".to_string())
    }
}

// å¹³å°æŠ½è±¡å±‚ - ç»Ÿä¸€æ¥å£
pub struct WindowOperationsImpl;

impl WindowOperations for WindowOperationsImpl {
    fn get_all_windows_with_size() -> Vec<WindowInfo> {
        #[cfg(windows)]
        return windows_impl::get_all_windows_with_size();
        #[cfg(unix)]
        return unix_impl::get_all_windows_with_size();
        #[cfg(not(any(windows, unix)))]
        return other_impl::get_all_windows_with_size();
    }

    fn find_windows(
        pid_filter: &Option<String>,
        name_filter: &Option<String>,
        title_filter: &Option<String>,
        process_names: &[(u32, String)],
    ) -> Vec<WindowHandle> {
        #[cfg(windows)]
        return windows_impl::find_windows(pid_filter, name_filter, title_filter, process_names);
        #[cfg(unix)]
        return unix_impl::find_windows(pid_filter, name_filter, title_filter, process_names);
        #[cfg(not(any(windows, unix)))]
        return other_impl::find_windows(pid_filter, name_filter, title_filter, process_names);
    }
}

// å¹³å°ç‰¹å®šçš„çª—å£æ“ä½œå‡½æ•°
mod platform {
    use super::WindowHandle;

    #[cfg(windows)]
    pub use super::windows_impl::{minimize_window, maximize_window, restore_window};
    
    #[cfg(unix)]
    pub use super::unix_impl::{minimize_window, maximize_window, restore_window};
    
    #[cfg(not(any(windows, unix)))]
    pub use super::other_impl::{minimize_window, maximize_window, restore_window};
}
```

```rust
// src/window/mod.rs
mod platform;
use crate::types::{WindowInfo, WindowRect};

// é‡æ–°å¯¼å‡ºå…¬å…±æ¥å£
pub use platform::{WindowOperations, WindowOperationsImpl, WindowHandle};

// ä¿æŒå‘åå…¼å®¹çš„å…¬å…±å‡½æ•°
pub fn get_all_windows_with_size() -> Vec<WindowInfo> {
    WindowOperationsImpl::get_all_windows_with_size()
}

pub fn get_all_windows() -> Vec<(u32, String)> {
    get_all_windows_with_size()
        .into_iter()
        .map(|window| (window.pid, window.title))
        .collect()
}

// çª—å£æ“ä½œæ¨¡å— - ç®€åŒ–åçš„ç»Ÿä¸€æ¥å£
pub mod manipulation {
    use super::*;

    pub fn find_windows(
        pid_filter: &Option<String>,
        name_filter: &Option<String>,
        title_filter: &Option<String>,
        process_names: &[(u32, String)],
    ) -> Vec<WindowHandle> {
        WindowOperationsImpl::find_windows(pid_filter, name_filter, title_filter, process_names)
    }

    // ç»Ÿä¸€çš„çª—å£æ“ä½œæ‰§è¡Œå™¨ï¼ˆä½¿ç”¨å¹³å°æŠ½è±¡ï¼‰
    pub fn execute_window_operation(
        operation: crate::main::WindowOperation,
        pid_filter: &Option<String>,
        name_filter: &Option<String>,
        title_filter: &Option<String>,
        process_names: &[(u32, String)],
        all: bool,
    ) -> Result<usize, String> {
        let windows = find_windows(pid_filter, name_filter, title_filter, process_names);
        
        if windows.is_empty() {
            return Err("No matching windows found".to_string());
        }

        if !all && windows.len() > 1 {
            return Err(format!(
                "Multiple windows found ({}). Use --all to {} all matching windows", 
                windows.len(), operation.as_str()
            ));
        }

        let mut count = 0;
        for window in windows {
            let result = match operation {
                crate::main::WindowOperation::Minimize => window.minimize(),
                crate::main::WindowOperation::Maximize => window.maximize(),
                crate::main::WindowOperation::Restore => window.restore(),
            };

            match result {
                Ok(()) => {
                    println!("{}: {} (PID: {})", operation.capitalized(), window.title, window.pid);
                    count += 1;
                }
                Err(e) => {
                    eprintln!("Failed to {} window {} (PID: {}): {}", 
                             operation.as_str(), window.title, window.pid, e);
                }
            }
        }

        Ok(count)
    }
}
```

```rust
// æ›´æ–° src/main.rs ä¸­çš„çª—å£æ“ä½œå¤„ç†
fn handle_window_operation_command(
    pid_filter: Option<String>,
    name_filter: Option<String>,
    title_filter: Option<String>,
    all: bool,
    operation: WindowOperation,
) -> Result<(), Box<dyn std::error::Error>> {
    // Get process names for filtering
    let processes = get_processes();
    let process_names: Vec<(u32, String)> = processes
        .iter()
        .map(|p| (p.pid.parse().unwrap_or(0), p.name.clone()))
        .collect();

    // ä½¿ç”¨ç»Ÿä¸€çš„çª—å£æ“ä½œæ‰§è¡Œå™¨
    match window::manipulation::execute_window_operation(
        operation,
        &pid_filter,
        &name_filter,
        &title_filter,
        &process_names,
        all
    ) {
        Ok(count) => {
            println!("Successfully {} {} window(s)", operation.past_tense(), count);
            Ok(())
        }
        Err(e) => Err(e.into()),
    }
}
```

```toml
# æ›´æ–° Cargo.toml ä¾èµ–
[package]
name = "pscan"
version = "0.1.0"
edition = "2021"

authors = ["YeMiancheng <ymc.github@gmail.com>"]
description = "A cross-platform process filtering and analysis tool with window detection support"
license = "MIT OR Apache-2.0"
repository = "https://github.com/ymc-github/pscan"
readme = "README.md"
keywords = ["process", "filter", "windows", "system", "monitor", "cli", "utility"]
categories = ["command-line-utilities", "system", "development-tools"]

[[bin]]
name = "pscan"
path = "src/main.rs"

[dependencies]
sysinfo = "0.30.5"
clap = { version = "4.4", features = ["derive"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.9"
csv = "1.3"

# å¹³å°ç‰¹å®šä¾èµ–
[target.'cfg(windows)'.dependencies]
windows = { version = "0.52", features = [
    "Win32_Foundation",
    "Win32_UI_WindowsAndMessaging", 
    "Win32_System_Threading",
] }

[target.'cfg(unix)'.dependencies]
# æœªæ¥å¯ä»¥æ·»åŠ  x11rb æˆ–å…¶ä»– Unix çª—å£ç³»ç»Ÿä¾èµ–
# x11rb = "0.12"
```

## ğŸ¯ ä¸»è¦é‡æ„ç‚¹

### 1. **ç»Ÿä¸€çš„å¹³å°æŠ½è±¡æ¥å£**
```rust
pub trait WindowOperations {
    fn get_all_windows_with_size() -> Vec<WindowInfo>;
    fn find_windows(...) -> Vec<WindowHandle>;
}
```
æ‰€æœ‰å¹³å°å®ç°ç›¸åŒçš„traitï¼Œç¡®ä¿æ¥å£ä¸€è‡´æ€§ã€‚

### 2. **å¹³å°æ— å…³çš„çª—å£å¥æŸ„**
```rust
pub struct WindowHandle {
    pub pid: u32,
    pub title: String,
    #[cfg(windows)] pub hwnd: HWND,
    #[cfg(unix)] pub window_id: u64,
}
```
ç»Ÿä¸€çš„æ•°æ®ç»“æ„ï¼Œå¹³å°ç‰¹å®šå­—æ®µä½¿ç”¨æ¡ä»¶ç¼–è¯‘ã€‚

### 3. **æ¶ˆé™¤é‡å¤çš„æ¡ä»¶ç¼–è¯‘**
- åŸæ¥çš„manipulationæ¨¡å—ä¸­é‡å¤çš„Windows/éWindowså®ç°
- ç°åœ¨æ¯ä¸ªå¹³å°æœ‰ç‹¬ç«‹çš„å®ç°æ¨¡å—
- ç»Ÿä¸€çš„æ¥å£å±‚å¤„ç†å¹³å°åˆ†å‘

### 4. **æ›´å¥½çš„é”™è¯¯å¤„ç†**
```rust
impl WindowHandle {
    pub fn minimize(&self) -> Result<(), String> {
        platform::minimize_window(self)
    }
}
```
ç»Ÿä¸€çš„é”™è¯¯ç±»å‹å’Œé”™è¯¯æ¶ˆæ¯ã€‚

### 5. **æ˜“äºæ‰©å±•**
- æ·»åŠ æ–°å¹³å°åªéœ€å®ç°`WindowOperations` trait
- ç°æœ‰ä»£ç æ— éœ€ä¿®æ”¹
- æ¸…æ™°çš„å¹³å°è¾¹ç•Œ

## ğŸ“Š é‡æ„ä¼˜åŠ¿

### æ¶ˆé™¤çš„é‡å¤ï¼š
- **æ¡ä»¶ç¼–è¯‘é€»è¾‘** - åŸæ¥åœ¨å¤šä¸ªå‡½æ•°ä¸­é‡å¤çš„`#[cfg(windows)]`
- **é”™è¯¯å¤„ç†ä»£ç ** - ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æ¨¡å¼
- **çª—å£æŸ¥æ‰¾é€»è¾‘** - ç»Ÿä¸€çš„è¿‡æ»¤å’ŒéªŒè¯é€»è¾‘

### æé«˜çš„å¯ç»´æŠ¤æ€§ï¼š
- **å•ä¸€èŒè´£** - æ¯ä¸ªå¹³å°æ¨¡å—åªè´Ÿè´£è‡ªå·±çš„å®ç°
- **å¼€é—­åŸåˆ™** - æ·»åŠ æ–°å¹³å°ä¸ä¿®æ”¹ç°æœ‰ä»£ç 
- **æ›´å¥½çš„æµ‹è¯•** - å¯ä»¥ç‹¬ç«‹æµ‹è¯•æ¯ä¸ªå¹³å°å®ç°

### æ›´å¥½çš„è·¨å¹³å°æ”¯æŒï¼š
- **æ¸…æ™°çš„å¹³å°æŠ½è±¡** - å¹³å°ç‰¹å®šä»£ç éš”ç¦»åœ¨ç‹¬ç«‹æ¨¡å—
- **ç»Ÿä¸€çš„æ¥å£** - æ‰€æœ‰å¹³å°æä¾›ç›¸åŒçš„åŠŸèƒ½æ¥å£
- **æ¸è¿›å¼å®ç°** - å¯ä»¥é€æ­¥å®Œå–„å„å¹³å°åŠŸèƒ½

è¿™ä¸ªé‡æ„æ˜¾è‘—æ”¹å–„äº†ä»£ç çš„è·¨å¹³å°æ¶æ„ï¼Œä½¿æ·»åŠ æ–°å¹³å°æ”¯æŒå’Œç»´æŠ¤ç°æœ‰å¹³å°å˜å¾—æ›´åŠ å®¹æ˜“ã€‚